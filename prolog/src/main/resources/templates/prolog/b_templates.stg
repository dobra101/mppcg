// TODO: use remaining variables
machine(name, parameters, constraints, sets, constants, concrete_constants, properties, definitions, variables, concrete_variables, invariant, assertions, initialization, operations, methods, whileDefinitions) ::= <<
:- use_module(library(avl)).

<if(sets)>
<sets; separator=".\n\n">.
<endif>

<if(concrete_constants)>
<concrete_constants; separator="\n\n">
<endif>

<initialization>

% Transitions
<operations; separator="\n\n">

% Invariant
<invariant>

% Custom predicates
<methods; separator="\n\n">

% While definitions
<whileDefinitions; separator="\n\n">

is_list([]) :- !.
is_list([_ | Tail]) :-
    is_list(Tail).

% AVL
get(State, Key, Value) :-
    avl:avl_fetch(Key, State, Value).

empty(T) :- avl:empty_avl(T).

update(Key, Value, AVL, NewAVL) :-
    avl:avl_store(Key, AVL, Value, NewAVL).

avl2List(AVL, List) :-
    avl:avl_to_list(AVL, List).
>>

// TODO: improve return values
operation(name, parameters, returnValues, body, resultStateCount) ::= <<
<if(returnValues)>
out(State_0, '<name>', Value) :-
    <body>,
    get(State_<resultStateCount>, '<returnValues>', Value).<else>
trans('<name>'<if(parameters)>(<parameters :{ p | <p>=Expr_<p>}; separator=", ">)<endif>, State_0, State_<resultStateCount>) :-
    <body>.<endif>
>>

// TODO: use type and mapType
function(lhs, rhs, type, mapType) ::= <<
function(<lhs>, <rhs>)
>>

binaryFunctionExpression(lhs, rhs, operator, exprCount) ::= <<
<operator>(<lhs>, <rhs>, Expr_<exprCount>)
>>

callFunction(expression, parameters, exprCount) ::= <<
callFunction(<expression>, <parameters>, Expr_<exprCount>)
>>

callFunctionPredicate(memberName) ::= <<
callFunction(Expression, Parameters, Result) :-
    is_list(Parameters),
    findall(Y, (<memberName>(X, Parameters), <memberName>((X/Y), Expression)), Res),
    flatten(Res, Flat),
    (Flat = [Result]; Result = Flat),
    !.
callFunction(Expression, X, Result) :-
    \+ is_list(X),
    findall(Y, <memberName>((X/Y), Expression), Res),
    flatten(Res, Flat),
    (Flat = [Result]; Result = Flat),
    !.

flatten(L, Res) :-
    flatten(L, [], Flat),
    (L = [set(_) | _] -> (sort(Flat, R), Res = set(R)); Res = Flat).
flatten([], Acc, Acc) :- !.
flatten([Head | Tail], Acc, Flat) :-
    (is_list(Head) -> append(Head, Acc, NewAcc); append([Head], Acc, NewAcc)),
    flatten(Tail, NewAcc, Flat).
flatten([set(Head) | Tail], Acc, Flat) :-
    (is_list(Head) -> append(Head, Acc, NewAcc); append([Head], Acc, NewAcc)),
    flatten(Tail, NewAcc, Flat).
>>

concreteIdentifier(name, value, inline) ::= <<
<if(inline)><name>(<value>).<else>
<name>(Result) :-
    <value>.<endif>
>>

couple(from, to) ::= <<
(<from>/<to>)
>>

unaryFunctionExpression(expression, operator, exprCount) ::= <<
<operator>(<expression>, Expr_<exprCount>)
>>

invariant(body, idx) ::= <<
check_inv_<idx>(State_0) :-
    <body>,
    !.
>>

invariants(list) ::= <<
<list; separator="\n\n">
>>

quantifier(identifier, predicate, quantification, universalQuantifier) ::= <<
<if(universalQuantifier)><if(quantification)>
% universal quantifier
findall(
    _,
   (
    <predicate>,
    \+ (
        <quantification>
        )
    ),
    []
)<else>
findall(
    _,
   (
    <predicate>
    ),
    []
)<endif><else>
% exist quantifier
<predicate><if(quantification)>,
<quantification><endif><endif>
>>

lambdaExpression(identifier, predicate, expression, value, exprCount) ::= <<
findall(
    (<identifier>/<value>),
    (
        <predicate>,
        <expression>
    ),
    Res_<exprCount>
),
sort(Res_<exprCount>, Expr_<exprCount>)
>>

initialization(body, resultStateCount) ::= <<
start(State_<resultStateCount>) :-
    empty(State_0),
    <body; separator=",\n">.
>>

// TODO: make parallel
parallelSubstitution(tempVars, substitutions) ::= <<
% Parallel Substitution:
<if(tempVars)><tempVars; separator=",\n">,<endif>
<substitutions; separator=",\n">
>>

precondition(predicate, substitution) ::= <<
<predicate>,
<substitution>
>>

// TODO: add else, when
select(condition, then, elseSubstitution, when) ::= <<
% Select
<condition>,

% Then
<if(then)><then><else>true<endif>
>>

comprehensionSetExpression(identifiers, predicates, exprCount) ::= <<
findall(
    (<identifiers; separator="/">),
    (
        <predicates; separator=",\n">
    ),
    Res_<exprCount>),
sort(Res_<exprCount>, Expr_<exprCount>_l),
Expr_<exprCount> = set(Expr_<exprCount>_l)
>>


/* XTL */
props(invariants, indices) ::= <<
prop(State, unsafe) :-
    \+ check_inv(State),
    !.
prop(State, List) :-
    avl2List(State, List),
    !.

check_inv(State) :-
    <indices :{ idx | check_inv_<idx>(State),}; separator="\n">
    !.

<invariants>
>>

// TODO: function: check if e.g. only one solution is found
member(name) ::= <<
<name>(Element, 'INT') :-
    integer(Element).
<name>(Element, 'NAT') :-
    integer(Element),
    between(0, infinite, Element).
<name>(Element, (A, B)) :-
    between(A, B, Element).
<name>(Set, function(From, To)) :-
    findall(_, (<name>(E, Set), \+ <name>(E, function(From, To))), []).
<name>(set(Set), function(From, To)) :-
    findall(_, (<name>(E, Set), \+ <name>(E, function(From, To))), []).
<name>((X/Y), function(From, To)) :-
    <name>(X, From),
    <name>(Y, To).
<name>(Element, set(Set)) :-
    <name>(Element, Set).
<name>(Element, List) :-
    is_list(List),
    member(Element, List).

between(A, B, Element) :-
    var(Element),
    gen_int_between(A, B, Element).
between(A, B, Element) :-
    integer(Element),
    Element >= A,
    (B \= infinite -> Element =\< B; true).

gen_int_between(Start, infinite, Start).
gen_int_between(Start, End, Start) :-
    End \= infinite,
    Start =\< End.
gen_int_between(Start, infinite, Int) :-
    Start1 is Start + 1,
    gen_int_between(Start1, infinite, Int).
gen_int_between(Start, End, Int) :-
    End \= infinite,
    Start =\< End,
    Start1 is Start + 1,
    gen_int_between(Start1, End, Int).
>>

subset(name) ::= <<
<name>(set(Left), set(Right)) :-
    findall(X, (member(X, Left), member(X, Right)), Left).
<name>([], []).
<name>([Head | NewTail], [Head | Tail]) :-
    <name>(NewTail, Tail).
<name>(NewTail, [_ | Tail]) :-
    <name>(NewTail, Tail).
>>

setSubtraction(name) ::= <<
<name>(set(Left), set(Right), set(Result)) :-
    findall(X, (member(X, Left), \+ member(X, Right)), Res),
    sort(Res, Result).
>>

setIntersection(name) ::= <<
<name>(set(Left), set(Right), set(Intersection)) :-
    findall(X, (member(X, Left), member(X, Right)), Inter),
    sort(Inter, Intersection).
>>

setUnion(name) ::= <<
<name>(set(Left), set(Right), set(Union)) :-
    append(Left, Right, Appended),
    sort(Appended, Union).
>>

domain(name) ::= <<
<name>(set(Relation), set(Domain)) :-
    <name>(Relation, Domain).
<name>([], []) :- !.
<name>([(X/_) | Tail], [X | NewTail]) :-
    <name>(Tail, NewTail).
>>

range(name) ::= <<
<name>(set(Relation), set(Range)) :-
    <name>(Relation, Range).
<name>([], []) :- !.
<name>([(_/Y) | Tail], [Y | NewTail]) :-
    <name>(Tail, NewTail).
>>

reverse(name) ::= <<
<name>([], []) :- !.
<name>([(X/Y) | Tail], [(Y/X) | NewTail]) :-
    <name>(Tail, NewTail),
    !.
>>

domainRestriction(name) ::= <<
<name>(Domain, set(Set), set(Result)) :-
    <name>(Domain, Set, Result),
    !.
<name>(_, [], []) :- !.
<name>(Domain, [(X/Y) | Tail], [(X/Y) | NewTail]) :-
     member(X, Domain),
     <name>(Domain, Tail, NewTail),
     !.
<name>(Domain, [_ | Tail], NewTail) :-
    <name>(Domain, Tail, NewTail),
    !.
>>

domainSubtraction(name) ::= <<
<name>(Domain, set(Set), set(Result)) :-
    <name>(Domain, Set, Result),
    !.
<name>(_, [], []) :- !.
<name>(Domain, [(X/Y) | Tail], [(X/Y) | NewTail]) :-
    \+ member(X, Domain),
    <name>(Domain, Tail, NewTail),
    !.
<name>(Domain, [_ | Tail], NewTail) :-
    <name>(Domain, Tail, NewTail),
    !.
>>

image(name, memberName) ::= <<
<name>(Relation, set(Set), set(Image)) :-
    <name>(Relation, Set, Image),
    !.
<name>(_, [], []) :- !.
% image of set
<name>(Relation, [X | Rest], Image) :-
    findall(Y, <memberName>((X/Y), Relation), Ys),
    <name>(Relation, Rest, OtherTail),
    append(Ys, OtherTail, Image),
    !.
<name>(Relation, [_ | Rest], NewTail) :-
    <name>(Relation, Rest, NewTail).
% image of interval
<name>(Relation, (A, B), Result) :-
    findall(Element, <memberName>(Element, (A, B)), Set),
    <name>(Relation, Set, Result),
    !.
>>

overwrite(name, domainName, domainSubtractionName) ::= <<
<name>(Overridden, Set, Result) :-
    <domainName>(Set, Domain),
    <domainSubtractionName>(Domain, Overridden, Tail),
    ((Tail = set(T), Set = set(S)) -> append(S, T, Result); append(Set, Tail, Result)).
>>

rangeRestriction(name) ::= <<
<name>(Relation, set(Set), set(Result)) :-
    <name>(Relation, Set, Result),
    !.
<name>([], _, []) :- !.
<name>([(X/Y) | Tail], Range, [(X/Y) | NewTail]) :-
    member(Y, Range),
    <name>(Tail, Range, NewTail),
    !.
<name>([_ | Tail], Range, NewTail) :-
    <name>(Tail, Range, NewTail),
    !.
>>

rangeSubtraction(name) ::= <<
<name>(Relation, set(Set), set(Result)) :-
    <name>(Relation, Set, Result),
    !.
<name>([], _, []) :- !.
<name>([(X/Y) | Tail], Range, [(X/Y) | NewTail]) :-
    \+ member(Y, Range),
    <name>(Tail, Range, NewTail),
    !.
<name>([_ | Tail], Range, NewTail) :-
    <name>(Tail, Range, NewTail),
    !.
>>

powerSet(name, subsetName) ::= <<
<name>(set(Set), Powerset) :-
    <name>(Set, Powerset),
    !.
<name>(Set, set(Sorted)) :-
    findall(set(Subset), (<subsetName>(Sub, Set), sort(Sub, Subset)), Powerset),
    sort(Powerset, Sorted),
    !.
>>

powerSet1(name, subsetName) ::= <<
<name>(set(Set), Powerset) :-
    <name>(Set, Powerset),
    !.
<name>(Set, set(Sorted)) :-
    findall(set(Subset), (<subsetName>(Sub, Set), sort(Sub, Subset), Subset \= []), Powerset),
    sort(Powerset, Sorted),
    !.
>>

maxSet(name) ::= <<
<name>(set(Set), Max) :-
    <name>(Set, Max),
    !.
<name>(Set, Max) :-
    <name>(Set, unset, Max),
    !.
<name>([], unset, unset) :- fail, !.
<name>([Head | Tail], unset, Max) :-
    <name>(Tail, Head, Max),
    !.
<name>([], Acc, Acc) :- !.
<name>([Head | Tail], Acc, Max) :-
    Head \> Acc,
    <name>(Tail, Head, Max),
    !.
<name>([_ | Tail], Acc, Max) :-
    <name>(Tail, Acc, Max),
    !.
>>

minSet(name) ::= <<
<name>(set(Set), Min) :-
    <name>(Set, Min),
    !.
<name>(Set, Min) :-
    <name>(Set, unset, Min),
    !.
<name>([], unset, unset) :- fail, !.
<name>([Head | Tail], unset, Min) :-
    <name>(Tail, Head, Min),
    !.
<name>([], Acc, Acc) :- !.
<name>([Head | Tail], Acc, Min) :-
    Head \< Acc,
    <name>(Tail, Head, Min),
    !.
<name>([_ | Tail], Acc, Min) :-
    <name>(Tail, Acc, Min),
    !.
>>

cardinality(name) ::= <<
<name>(set(List),  Length) :-
    length(List, Length),
    !.
<name>(List, Length) :-
    is_list(List),
    length(List, Length),
    !.
>>

updateStateCount(newCount, oldCount) ::= <<
State_<newCount> = State_<oldCount>
>>

updateExprCount(newCount, oldCount) ::= <<
Expr_<newCount> = Expr_<oldCount>
>>

infiniteSetExpression(type) ::= <<
<type>
>>

sequence(elements) ::= <<
[<elements; separator=", ">]
>>

unarySequenceExpression(sequence, operator, exprCount) ::= <<
<operator>(<sequence>, Expr_<exprCount>)
>>

binarySequenceExpression(lhs, rhs, operator, exprCount) ::= <<
<operator>(<lhs>, <rhs>, Expr_<exprCount>)
>>

sequenceFront(name) ::= <<
<name>(Sequence, Front) :-
    append(Front, [_], Sequence),
    !.
>>

sequenceTail(name) ::= <<
<name>([_ | Tail], Tail) :- !-
>>

sequenceFirst(name) ::= <<
<name>([First | _], First).
>>

sequenceLast(name) ::= <<
<name>([Last], Last).
<name>([_ | Tail|, Last) :-
    <name>(Tail, Last).
>>

sequenceRestrictFront(name) ::= <<
<name>([], _, []) :- !.
<name>(_, 0, []) :- !.
<name>([Head | Tail], N, [Head | NewTail]) :-
    N1 is N - 1,
    <name>(Tail, N1, NewTail).
>>

sequenceRestrictTail(name) ::= <<
<name>(Sequence, N, Sequence) :-
    length(Sequence, L),
    L =\< N,
    !.
<name>([_ | Tail], N, Result) :-
    <name>(Tail, N, Result).
>>

sequenceReverse(name) ::= <<
<name>([], []).
<name>([Head | Tail], Reversed) :-
    <name>(Tail, ReversedTail),
    append(ReversedTail, [Head], Reversed).
>>