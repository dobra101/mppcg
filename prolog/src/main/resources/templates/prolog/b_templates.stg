// TODO: use remaining variables
machine(name, parameters, constraints, sets, constants, concrete_constants, properties, definitions, variables, concrete_variables, invariant, assertions, initialization, operations, methods) ::= <<
:- use_module(library(avl)).

<if(sets)>
<sets; separator=".\n\n">.
<endif>

<initialization>

% Transitions
<operations; separator="\n\n">

% Invariant
<invariant>

% Custom predicates
<methods; separator="\n\n">

is_list([]) :- !.
is_list([_ | Tail]) :-
    is_list(Tail).

% AVL
get(State, Key, Value) :-
    avl:avl_fetch(Key, State, Value).

empty(T) :- avl:empty_avl(T).

update(Key, Value, AVL, NewAVL) :-
    avl:avl_store(Key, AVL, Value, NewAVL).

avl2List(AVL, List) :-
    avl:avl_to_list(AVL, List).
>>

// TODO: add returnValues ?
operation(name, parameters, body, resultStateCount) ::= <<
trans('<name>', State_0, State_<resultStateCount>) :-
    <body>.
>>

// TODO: implement
function(lhs, rhs, type, mapType) ::= <<
Function:
lhs: <lhs>
rhs: <rhs>
Type: <type>
mapType: <mapType>
>>

binaryFunctionExpression(lhs, rhs, operator, exprCount) ::= <<
<operator>(<lhs>, <rhs>, Expr_<exprCount>)
>>

callFunction(expression, parameters, exprCount) ::= <<
callFunction(<expression>, <parameters>, Expr_<exprCount>)
>>

couple(list) ::= <<
Couple:
List: <list>
>>

unaryFunctionExpression(expression, operator, exprCount) ::= <<
<operator>(<expression>, Expr_<exprCount>)
>>

invariant(body, idx) ::= <<
check_inv_<idx>(State_0) :-
    <body>,
    !.
>>

invariants(list) ::= <<
<list; separator="\n\n">
>>

quantifier(identifier, predicate, type) ::= <<
Quantifier:
Identifier: <identifier>
Predicate: <predicate>
Type: <type>
>>

initialization(body, resultStateCount) ::= <<
start(State_<resultStateCount>) :-
    empty(State_0),
    <body; separator=",\n">.
>>

// TODO: make parallel
parallelSubstitution(substitutions) ::= <<
% Parallel Substitution:
<substitutions; separator=",\n">
>>

precondition(predicate, substitution) ::= <<
<predicate>,
<substitution>
>>

// TODO: add else, when
select(condition, then, elseSubstitution, when) ::= <<
<condition>,
<then>
>>


/* XTL */
props(invariants, indices) ::= <<
prop(State, unsafe) :-
    \+ check_inv(State),
    !.
prop(State, List) :-
    avl2List(State, List),
    !.

check_inv(State) :-
    <indices :{ idx | check_inv_<idx>(State),}; separator="\n">
    !.

<invariants>
>>

member(name) ::= <<
<name>(Element, 'NAT') :-
    between(0, infinite, Element).
<name>(Element, List) :-
    is_list(List), !,
    member(Element, List).
<name>(Element, (A, B)) :-
    between(A, B, Element).

between(A, B, Element) :-
    var(Element),
    gen_int_between(A, B, Element).
between(A, B, Element) :-
    integer(Element),
    Element >= A,
    (B \= infinite -> Element =\< B; true).

gen_int_between(Start, infinite, Start).
gen_int_between(Start, End, Start) :-
    End \= infinite,
    Start =\< End.
gen_int_between(Start, infinite, Int) :-
    Start1 is Start + 1,
    gen_int_between(Start1, infinite, Int).
gen_int_between(Start, End, Int) :-
    End \= infinite,
    Start =\< End,
    Start1 is Start + 1,
    gen_int_between(Start1, End, Int).
>>

subset(name) ::= <<
<name>([], []).
<name>([Head | NewTail], [Head | Tail]) :-
    <name>(NewTail, Tail).
<name>(NewTail, [_ | Tail]) :-
    <name>(NewTail, Tail).
>>

setSubtraction(name) ::= <<
<name>([], _, []) :- !.
<name>([Head | Tail], Minus, [Head | NewTail]) :-
    is_list(Minus),
    \+ member(Head, Minus),
    <name>(Tail, Minus, NewTail),
    !.
<name>([_ | Tail], Minus, NewTail) :-
    is_list(Minus),
    <name>(Tail, Minus, NewTail),
    !.
<name>([Head | Tail], Head, NewTail) :-
    \+ is_list(Head),
    <name>(Tail, Head, NewTail),
    !.
<name>([Head | Tail], Minus, [Head | NewTail]) :-
    \+ is_list(Minus),
    Head \= Minus,
    <name>(Tail, Minus, NewTail),
    !.
>>

setIntersection(name) ::= <<
<name>([], _, []) :- !.
<name>(_, [], []) :- !.
<name>([Head | Tail], List, [Head | NewTail]) :-
    member(Head, List),
    <name>(Tail, List, NewTail),
    !.
<name>([_ | Tail], List, NewTail) :-
    <name>(Tail, List, NewTail),
    !.
>>

setUnion(name) ::= <<
<name>([], Set, Set) :- !.
<name>([Head | Tail], Set, [Head | NewTail]) :-
    \+ member(Head, Set),
    <name>(Tail, Set, NewTail),
    !.
<name>([_ | Tail], Set, NewTail) :-
    <name>(Tail, Set, NewTail),
    !.
>>

domain() ::= <<
>>

range() ::= <<
>>

reverse() ::= <<
>>

domainRestriction() ::= <<
>>

domainSubtraction() ::= <<
>>

image() ::= <<
>>

overwrite() ::= <<
>>

rangeRestriction() ::= <<
>>

rangeSubtraction() ::= <<
>>

powerSet(name, subsetName) ::= <<
<name>(Set, Powerset) :-
    findall(Subset, <subsetName>(Subset, Set), Powerset),
    !.
>>

cardinality(name) ::= <<
<name>
>>

updateStateCount(newCount, oldCount) ::= <<
State_<newCount> = State_<oldCount>
>>

updateExprCount(newCount, oldCount) ::= <<
Expr_<newCount> = Expr_<oldCount>
>>

infiniteSetExpression(type) ::= <<
<type>
>>