machine(name, parameters, constraints, sets, constants, concrete_constants, properties, definitions, variables, concrete_variables, initialization, invariant, assertions, operations, transitions) ::= <<

public class <name> {
    <parameters>
    <constraints>
    <sets>

    <constants; separator="\n">
    <concrete_constants; separator="\n">
    <variables; separator="\n">

    <properties>
    <definitions>
    <concrete_variables>
    <assertions>
    <initialization>

    <operations; separator="\n\n">

    <transitions; separator="\n\n">

    <invariant>
}
>>

// TODO: add return values
operation(name, parameters, body) ::= <<
public void <name>(<parameters>) {
    <body>
}
>>

transition(name, body) ::= <<
public boolean tr_<name>() {
    return <body>;
}
>>

function(left, right) ::= <<
<left>[<right>]
>>

invariant(body, idx) ::= <<
public boolean check_inv_<idx>() {
    return <body>;
}
>>

invariants(list) ::= <<
<list; separator="\n\n">
>>

initialization(substitutions, name) ::= <<
public <name>() {
    <substitutions; separator="\n">
}
>>

precondition(predicate, substitution) ::= <<
<predicate>
<substitution>
>>

// TODO: only else, when
select(condition, then, elseSubstitution, when) ::= <<
<then>
>>

// TODO: make parallel
parallelSubstitution(substitutions) ::= <<
// Parallel Substitution:
<substitutions; separator="\n">
>>

concreteIdentifier(name, value, type) ::= <<
<type> <name> = <value>;
>>

lambdaExpression(identifier, predicate, expression) ::= <<
Lambda:
I: <identifier>
P: <predicate>
E: <expression>
>>

callFunction(expression, parameters) ::= <<
<expression>[<parameters>]
>>

binaryFunctionExpression(left, right, operator) ::= <<
<left>.<operator>(<right>)
>>

couple(from, to) ::= <<
new BCouple(<from>, <to>)
>>